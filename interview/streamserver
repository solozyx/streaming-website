流媒体服务 不和db交互 没有session

【长连接】
和REST API短连接服务不同 streamserver
streaming 和 upload video file 使用长连接
client发request到server，server要不断向client输出数据流，持续时间长
upload video file时间可能会短一些，
多路长连接会出问题，如果不断发起连接，不断打开视频，会把server crash掉
增加 read limit 机制 流控机制

【流控机制】
与传统流控不同，这里只控制connection部分
服务上线运行 攻击者 用户有意无意 向网站发起请求
当请求达到一定数量， 导致server能提供的连接数不足 带宽占完
服务不可用

【bucket token算法】
bucket token 箱子中有N多个token
当request来从bucket中取出1个token发给它,箱子减少1个token
个客户端返回response后，客户端把token返回，箱子token还原1个
server最多能处理token个数的request

业界做流控 通用算法

func handleStreaming()
func handleUpload()
golang的每一个handler都是新起了1个goroutine，多个goroutine之间是并发的
在并发情况下，很可能有多个handler在同一时刻访问同一个变量
bucket也是内存中的一个数据块
加锁 来保证同步 整体性能下降
channel 共享管道
shared channel instead of shared memory 共享通道同步协程间数据而不用共享内存

【无buffer channel 和 有buffer channel】
无buffer channel 是同步channel 子协程1向无buffer channel写入1个data
需要另外非子协程1把这1个data读取走 否则 该channel 永远阻塞下去

有buffer channel 是异步channel做多个goroutine之间数据同步 buffer 保证在一定缓冲
区间内 同步数据

/*
多种方式 static video file --> streaming
1.video file -> bit stream 二进制直接发给client 数据量速度 带宽 可控 但是实现复杂
2.web server最简单通用方式 http.ServeContent() 简单网站的视频点播 规模不大都是该方式
*/
func handleStreaming(resp http.ResponseWriter, req *http.Request){
	videoLink = VIDEO_DIR + vid
	// open static video file
	if video,err = os.Open(videoLink); err != nil{
		sendErrorResponse(resp,http.StatusInternalServerError,"Internal error")
		return
	}
	// 设置response header
	// videoLink如果没有扩展名 真正的video二进制码 是视频mp4格式
	// 这里把文件内容强制设置为mp4 浏览器就能自动以mp4格式解析video 解析完自动组装视频播放
	resp.Header().Set("Content-Type","video/mp4")
	// 播放 ServeContent() 把video的二进制流 传给浏览器 ,浏览器拿到该二进制流
	// 按照 Content-Type 解析 自动播放
	// ServeContent(w ResponseWriter,req *Request,name string,modtime time.Time,
	// content io.ReadSeeker 保证执行ServeContent()时 视频播放流畅 )
	http.ServeContent(resp,req,"",time.Now(),video)
	// 文件指针关闭
	defer video.Close()
}


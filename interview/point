t = time.Now()
// "Jan 02 2006, 15:04:05" golang time parse 提供的时间模板
// 所谓的时间原点 怎么得到的 没人说得清 go官网也没有 是golang固定的格式
// 写错一点 t.Format() 失效 对go很熟的人每次用这个串儿parse time的时候
// 基本都会掉到坑里 去翻文档 go作者的恶作剧 搞这么一出 毫无逻辑 复杂无比
// go彩蛋之一 这个串儿的任何一个字符都是不能更改的
// M D y, HH:MM:SS
//
ctime = t.Format("Jan 02 2006, 15:04:05")

评论
一般只有增加查询，评论一让不能删除和修改

func ListComments(vid string, from, to int) (commentList []*model.Comment, err error) {
	// 返回参数列表 (commentList []*model.Comment,err error) 声明了一个slice 是nil空指针
	// 需要make空间初始化 长度为0的slice不是nil
	// NOTICE 后续调用者只需要判断 commentList的长度是否0 不需要判断它是否nil空指针 简化调用者判断复杂性
	// len(commentList) == 0
	commentList = make([]*model.Comment,0)
	...
}

var(
	// cache 外部Redis mongodb 一个系统增加模块和服务系统复杂度会增加
	// 引入第三方cache带来的好处 小于 开发增量 反而会成为负担
	// 所以本系统没有必要采用Redis session是和用户登录相关的
	// 数据量有限 使用go内置缓存足够
	//
	// sync.Map in_memory缓存 是 go1.9 加入的 在 1.9之前 使用 传统 buildin Map
	// 传统Map非常大的缺点 不支持并发读写 超过2个以上的协程同时并发去读写Map就会panic
	// 使用传统Map要加锁 非常不方便 开发者给社会提了多年意见 增加线程安全的Map
	// 在 1.9加入了 sync.Map 自己实现了线程安全机制 尤其在读上 并发读优化的非常极致
	// 即使 上千并发 上万并发 sync.Map 读取都十分平稳
	// 但是在并发写上 会有问题 并发写 不会报 key conflict 冲突 每次写都加 全局锁 耗时
	// 并发读 并发写 都好的东西 也不容易做到 综合起来 sync.Map 在并发读写表现可以接受
	// 如果用单协程访问 sync.Map 效率的提升并不明显
	sessionMap *sync.Map
)

block阻塞1个协程,不让它执行完退出 2 种方式
1.for{死循环}
2.无buffer channel 不往channel写数据 直接从channel读数据
